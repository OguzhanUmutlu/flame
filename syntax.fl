import math
import std

import math.sqrt // imports as sqrt
println(sqrt(16)) // 4
import math as m // imports math lib as m
println(m.sqrt(25)) // 5
import std as * // special import, imports everything from std without needing to prefix with std.
println(hash("hello")) // prints hash of "hello"

import mymodule as * // imports everything from mymodule but not recursively.
println(mysubmodule.hello()) // you have to still prefix with mysubmodule.

var x = 10 // int by default, 16 or 32 bits in size
var x: uint = 10 // unsigned integer, 16 or 32 bits in size
var x: isize = 10 // signed word
var x: usize = 10 // unsigned word

var x: i8 = 10
var x: i16 = 10
var x: i32 = 10
var x: i64 = 10
var x: i128 = 10

var x: u8 = 10
var x: u16 = 10
var x: u32 = 10
var x: u64 = 10
var x: u128 = 10

import llvm

var x: llvm._types.int<1024> = 10 // llvm signed integer of size 1024, any size works.
var x: llvm._types.uint<1024> = 10 // llvm unsigned integer of size 1024, any size works.
var x: llvm._types.int<5> = 14 // even allows non-powers of 2, and even ones smaller than 8
var x: llvm._types.uint<1> = 1 // either 0 or 1, acts like a boolean

alias i1024 = llvm._types.int<1024>

var x = SIMD<i32>(1, 2, 3, 4) // SIMD<iN | uN> where N is a positive integer

var x = true // has type 'bool'

var x = 'x' // has type 'char'

var x = 10
// if (x) { // errors, needs a boolean
if (x != 0) { // works
} else if (x == 0) {
} else {
}

fun myFun(a: int, b: float) {
    return a + b
}

fun otherFun<T : number>(a: T, b: T) {
    return a + b
}

struct Complex {
    init(public val re: f64, public val im: f64) {}

    operator +(other: Complex): Complex {
        return Complex(re + other.re, im + other.im)
    }

    operator *(other: number): Complex {
        return Complex(re * other, im * other)
    }
}

val i = Complex(0, 1)

var x = 5 + 7*i

struct Vec2 {
    init(public val x: f32, public val y: f32) {}

    operator +(other: Vec2): Vec2 {
        return Vec2(x + other.x, y + other.y)
    }
}

struct Vec3 {
    init(public val x: f32, public val y: f32, public val z: f32) {}

    operator +(other: Vec3) {
        return Vec3(x + other.x, y + other.y, z + other.z)
    }

    operator +=(other: Vec3) {
        x += other.x
        y += other.y
        z += other.z
    }
}

enum struct SomeEnum {
    A, // defaults to indexing at 0
    B  // 1
}

enum struct OtherEnum {
    A = 5,  // starts at 5
    B,      // 6
    C = 10, // can set manually
    D       // 11
}

enum struct CharEnum {
    A = 'a',  // understands char values
    B,        // 'b'
    C,        // 'c'
    D := 'y', // allows setting manually
    E         // 'e' // continues from last pattern
}

enum struct StringEnum {
    Hello = "Wello", // understands string values
    World,           // "World"
    Foo,             // "Foo"
    Bar := "Baz",    // allows setting manually
    Qux              // "Qux"
}

enum struct LowerEnum {
    Hello = "hello", // understands lowercase string values
    World,           // "world"
    Foo,             // "foo"
    Bar := "baz",    // allows setting manually
    Qux,             // "qux"
    Plugh = "Plugh", // allows switching rules mid-enum
    Xyzzy,           // "Xyzzy"
    Thud             // "Thud"
}

fun std.hash(vec: Vec3) {
    return hash(vec.x) ^ hash(vec.y) ^ hash(vec.z)
}

var x = (1, 2)

// you can also use if statements inside expressions
var y = if (x == (1, 2)) {
    println("hello world")
    5
} else 10

for (x in 0:10) {
    println(x) // 0 1 2 3 4 5 6 7 8 9
}

for (x in 10) { // same as 0:10
    println(x) // 0 1 2 3 4 5 6 7 8 9
}

for (x in 0:10:2) { // step by 2
    println(x) // 0 2 4 6 8 10
}

for (x in -10) { // same as -10:0
    println(x) // -10 -9 -8 -7 -6 -5 -4 -3 -2 -1
}

while (x != 0) x--
do x-- while (x != 0)

struct Duration : usize {
    fun get inSeconds() = this / 1000
    fun get inMinutes() = this / 60000
    fun get inHours() = this / 3600000
    fun get inDays() = this / 86400000
}

fun get hello() {
    return 5
}

fun get Duration.days() {
    return this / 86400000
}

interface IntAddable {
    operator +(x: int): int
}

fun doAdd(c: IntAddable, x: int) { // same as doAdd<T : IntAddable>(c: T, x: int)
  return c + x
}

fun run(x: () -> void) {
  x()
}

run(() -> {
  println("hi")
})

run(() -> {
  println("hi")
})

fun addAsk(x: (int, int) -> int) {
  return x(2, 3)
}

five = addAsk((x, y) -> { x + y })

fun doSomething(x: int = 10, y: int = 20) {
  println(x + y)
}

doSomething(y: 30) // prints 40
doSomething() // prints 30
doSomething(5) // prints 25

fun spreadArgs(x: int = 5, ...rest: int[]) {
  println(x)
  for (arg in rest) {
    println(arg)
  }
}

spreadArgs(1, 2, 3, 4) // prints 1 2 3 4
val arr = [1, 2, 3, 4] // defaults to int[]
spreadArgs(...arr)

fun keywordArgs(...rest: (string, int)[]) {
  for (key, value in rest) {
    println(key + ": " + value)
  }
}

keywordArgs(a: 1, b: 2, c: 3) // prints a: 1 b: 2 c: 3
